---
title: "Test"
output: html_document
date: "2025-10-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(shiny)
library(dplyr)
library(lubridate)
library(httr)
library(xml2)
library(purrr)
library(stringr)
library(tibble)

```



```{r cars, include = F}
send_telegram <- function(message) {
  bot_token <- Sys.getenv("Telegram_BOT")
  chat_id   <- 75538067
  url <- paste0("https://api.telegram.org/bot", bot_token, "/sendMessage")
  POST(url, body = list(chat_id = chat_id, text = message), encode = "form")
}

# -------------------
# Funktion: Stop-Knoten aus XML in tibble
# -------------------
parse_stop <- function(stop, include_trip = FALSE) {
  stop_attr <- as.list(xml_attrs(stop))
  
  ar <- xml_find_first(stop, ".//ar")
  ar_attr <- if (!is.na(ar)) as.list(xml_attrs(ar)) else list()
  
  dp <- xml_find_first(stop, ".//dp")
  dp_attr <- if (!is.na(dp)) as.list(xml_attrs(dp)) else list()
  
  msgs <- xml_find_all(stop, ".//m")
  msg_attr <- if(length(msgs) > 0) {
    paste(sapply(msgs, function(m) paste(xml_attrs(m), collapse=";")), collapse=" | ")
  } else {
    NA_character_
  }
  
  if(include_trip) {
    tl <- xml_find_first(stop, ".//tl")
    tl_attr <- if (!is.na(tl)) as.list(xml_attrs(tl)) else list()
    tibble(stop_attr = list(stop_attr), tl_attr = list(tl_attr), ar_attr = list(ar_attr), dp_attr = list(dp_attr), messages = msg_attr)
  } else {
    tibble(stop_attr = list(stop_attr), ar_attr = list(ar_attr), dp_attr = list(dp_attr), messages = msg_attr)
  }
}

# -------------------
# Shiny App
# -------------------

    # -------------------
    # MESZ-Zeit für alles
    # -------------------
    now_berlin <- with_tz(Sys.time(), "Europe/Berlin")
    
    # -------------------
    # Parameter
    # -------------------
    evaNo <- 8000312
    client_id <- "4d202863a4c79e8d7e069b9ef38b57f7"
    client_secret <- Sys.getenv("DB_API")
    date <- format(now_berlin, "%y%m%d")
    current_hour_int <- as.integer(format(now_berlin, "%H"))
    hours_vector <- (current_hour_int + 0:2) %% 24
    zeit <- sprintf("%02d", hours_vector)
    
    plan_list <- list()
    
    for(hour in zeit){
      url_plan <- paste0("https://apis.deutschebahn.com/db-api-marketplace/apis/timetables/v1/plan/", evaNo, "/", date, "/", hour)
      res <- GET(url_plan, add_headers("DB-Client-Id" = client_id, "DB-Api-Key" = client_secret, "accept" = "application/xml"))
      if(status_code(res) != 200) stop("Fehler bei PLAN API: ", status_code(res))
      xml_plan <- content(res, "raw") %>% read_xml()
      stops_plan <- xml_find_all(xml_plan, ".//s")
      plan <- map_df(stops_plan, parse_stop, include_trip = TRUE)
      
      plan_simple <- plan %>%
        mutate(
          stop_id  = map_chr(stop_attr, ~ .x[["id"]] %||% NA_character_),
          eva      = map_chr(stop_attr, ~ .x[["eva"]] %||% NA_character_),
          trip_n   = map_chr(tl_attr, ~ .x[["n"]] %||% NA_character_),
          trip_cat = map_chr(tl_attr, ~ .x[["c"]] %||% NA_character_),
          arr_pt   = map_chr(ar_attr, ~ .x[["pt"]] %||% NA_character_),
          arr_line = map_chr(ar_attr, ~ .x[["l"]] %||% NA_character_),
          arr_ppth = map_chr(ar_attr, ~ .x[["ppth"]] %||% NA_character_),
          dep_pt   = map_chr(dp_attr, ~ .x[["pt"]] %||% NA_character_),
          dep_line = map_chr(dp_attr, ~ .x[["l"]] %||% NA_character_),
          dep_ppth = map_chr(dp_attr, ~ .x[["ppth"]] %||% NA_character_)
        ) %>%
        mutate(
          arr_time = parse_date_time(arr_pt, orders = "ymdHM", tz = "Europe/Berlin"),
          dep_time = parse_date_time(dep_pt, orders = "ymdHM", tz = "Europe/Berlin"),
          von  = coalesce(str_extract(arr_ppth, "^[^|]+"), "Rendsburg"),
          nach = coalesce(str_extract(dep_ppth, "(?<=\\|)[^|]+$"), "Rendsburg")
        ) %>%
        select(stop_id, eva, trip_n, trip_cat, dep_line, arr_ppth, von, dep_ppth, nach, arr_line, arr_time, dep_time, messages)
      
      plan_list[[length(plan_list)+1]] <- plan_simple
    }
    
    plan_simple <- bind_rows(plan_list)
    
    # -------------------
    # FCHG-Abfrage
    # -------------------
    url_fchg <- paste0("https://apis.deutschebahn.com/db-api-marketplace/apis/timetables/v1/fchg/", evaNo, "?schema=timetable")
    res <- GET(url_fchg, add_headers("DB-Client-Id" = client_id, "DB-Api-Key" = client_secret, "accept" = "application/xml"))
    if(status_code(res) != 200) stop("Fehler bei FCHG API: ", status_code(res))
    writeBin(content(res, "raw"), "fchg_hamburg.xml")
    xml_fchg <- read_xml("fchg_hamburg.xml")
    stops_fchg <- xml_find_all(xml_fchg, ".//s")
    fchg <- map_df(stops_fchg, parse_stop)
    
    fchg_simple <- fchg %>%
      mutate(
        stop_id       = map_chr(stop_attr, ~ .x[["id"]] %||% NA_character_),
        eva           = map_chr(stop_attr, ~ .x[["eva"]] %||% NA_character_),
        dep_ct        = map_chr(dp_attr, ~ .x[["ct"]]  %||% NA_character_),
        dep_clt       = map_chr(dp_attr, ~ .x[["clt"]] %||% NA_character_),
        dep_line_fchg = map_chr(dp_attr, ~ .x[["l"]]  %||% NA_character_),
        arr_ct        = map_chr(ar_attr, ~ .x[["ct"]]  %||% NA_character_),
        arr_clt       = map_chr(ar_attr, ~ .x[["clt"]] %||% NA_character_),
        arr_line_fchg = map_chr(ar_attr, ~ .x[["l"]]  %||% NA_character_)
      ) %>%
      mutate(
        dep_time_fchg = ymd_hm(dep_ct, tz = "Europe/Berlin"),
        arr_time_fchg = ymd_hm(arr_ct, tz = "Europe/Berlin")
      )
    
    # -------------------
    # Merge & Berechnungen
    # -------------------
    df_merged <- merge(plan_simple, fchg_simple, by = "stop_id", all.x = TRUE, suffixes = c("", "_fchg")) %>%
      mutate(
        is_canceled   = if_else(!is.na(dep_clt) | !is.na(arr_clt), TRUE, FALSE),
        dep_delay_min = as.numeric(difftime(dep_time_fchg, dep_time, units = "mins")),
        arr_delay_min = as.numeric(difftime(arr_time_fchg, arr_time, units = "mins")),
        dep_line = case_when(dep_line == "7" ~ "RE7", TRUE ~ dep_line),
        arr_line = case_when(arr_line == "7" ~ "RE7", TRUE ~ arr_line)
      )
    
    df_alert <- df_merged %>%
      filter(is_canceled | dep_delay_min >= 0 | arr_delay_min >= 0) %>%
      mutate(
        dep_time_fmt = format(dep_time, "%H:%M"),
        arr_time_fmt = format(arr_time, "%H:%M"),
        sort_time = coalesce(dep_time, arr_time)
      ) %>%
      arrange(sort_time)
    
    # -------------------
    # Telegram Nachricht
    # -------------------
    if(nrow(df_alert) > 0){
      header <- paste0("🚨 Meldungen Stand: ", format(now_berlin, "%H:%M"), " Uhr\n\n")
      body <- paste0(
        ifelse(!is.na(df_alert$dep_line) & df_alert$dep_line != "",
               paste0(df_alert$dep_line, " ", df_alert$von, " \u27A4 ", df_alert$nach, "\n",
                      "Abfahrt: ", format(df_alert$dep_time, "%H:%M"), "\n",
                      ifelse(df_alert$is_canceled, "❌ Zug fällt aus!", 
                             paste0("Momentane Verspätung: ", df_alert$dep_delay_min, " Minuten"))
               ),
               paste0(df_alert$arr_line, " ", df_alert$von, " \u27A4 ", df_alert$nach, "\n",
                      "Ankunft: ", format(df_alert$arr_time, "%H:%M"), "\n",
                      ifelse(df_alert$is_canceled, "❌ Zug fällt aus!", 
                             paste0("Momentane Verspätung: ", df_alert$arr_delay_min, " Minuten"))
               )
        ), collapse = "\n\n")
      msg <- paste0(header, body)
      send_telegram(msg)
    }
    
    # -------------------
    # App automatisch schließen
    # -------------------
    
    Sys.sleep(5)

```
